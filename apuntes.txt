Tema 1

VCS sistema de control de versiones

 - Maquina del tiempo
	Permite ir atrás y adelante en instantáneas (commit) creadas 	anteriormente de dicho código

 -  Programación Colaborativa
	Permite a varias personas trabajar sobre el mismo codigo

git config –-global user.name
	muestra el nombre que usaremos en los commit
git config –-global user.email
	muestra el email que usaremos en los commit

un repositorio contiene ramas y una rama es una cadena de commits
master es la rama principal

git init se usa en un directorio una vez y se usa para crear un repositorio vacio. Solo tiene una rama vacia, sin commits.

Para crear un commit hay que dar 2 pasos

	1.  movemos del directorio de trabajo al area de preparacion 	todo lo que queramos añadir al repertorio con git add (git 	add . añade todo el directorio actual, no es lo mismo que git 
	add * porque no añade los archivos ocultos)
	en este instante existe 2 archivos, si modificamos el 	original no se cambia el del area de preparacion. Si añadimos 	el original con otro git add, machaca al que esta en el area 	de preparacion. Tambien podemos descartar los cambios del 	directorio de trabajo con git checkout 
	con git reset head (nombrearchivo) sacamos el archivo del 	area de preparacion 

con git status nos da la situacion actual

	2. una vez añadido al area de preparacion, usamos git commit 	-m “mensaje a introducir” si es el primer commit deberiamos 	llamarlo “Initial commit”

el nombre de la rama apunta al commit mas reciente

el mensaje en el commit deberiamos añadir los cambios efectuados
las inserciones y los borrados se refieren a lineas

para ignorar archivos se usa el archivo .gitignore puedes usar el nombre o expresiones regulares

git log muestra la lista de todos los commits de la rama

tenemos creado un alias (atajo) con git lg que nos muestra el log mas conciso
el alias esta guardado en ~/.gitconfig

con git show vemos en detalle el contenido de un commit

HEAD ^ apunta al anterior HEAD
HEAD ~n apunta al head -N
	
git diff muestra la diferencia entre ficheros

si ponemos solo git diff muestra la diferencia entre el directorio de trabajo y el stage o con el HEAD si el stage esta vacio

para comparar stage con commit usamos git diff --staged ó –cached

para comparar dos commits ponemos git diff x..n siendo x y n los id de los commits, siendo x el inicial y n el final

deatached head (head deascoplado) no apunta una rama.

Git chechkout + id commit apunta el head a dicho commit

cuando añades un elemento al .gitignore si tiras para atrás el elemento no se borra, es decir, viaja al pasado, pero el gitignore no viaja al pasado

no se debe cambiar un commit pasado, solo puedes coger cosas de un commit

para volver a un commit anterior podemos hacer git revert que consiste en revertir los cambios hechos en un commit

si es el ultimo commit el que quieres anular podemos usar git reset + id del commit (--hard si queremos cambiar tambien el directorio de trabajo)

o si es el ultimo tambien se puede editar sobre ese ultimo commit y git commit --amend -m “mensaje”

podemos etiquetar commits con git tag + etiqueta + id del commit, asi no perderiamos commits que esten por detras de un reset(aun asi para verlo tendriamos que usar git lg –-all). Para borrrar etiquetas usamos git tag -d nombre

git rm = rm + git add

git mv = mv + git add

git no controla directorios vacias si queremos controlarlo creariamos un archivo .gitkeep en el directorio

Cuando trabajemos con multiples directorios y subdirectorios siempre debemos trabajar con git en la raiz

git branch te dice que ramas hay y en que ramas te encuentras, la rama en la que te encuentras la marca con un asterisco *
 
con git chechout -b nombre creamos una nueva rama que recien creada apuntara al commit que se este apuntando en este momento. Una vez creada te pasa a esa rama. Para que no nos pase a esa rama tendriamos que usar git branch nombre.

Para moverse a una rama usamos git checkout nombre

para eliminar una rama usamos git branch -d nombre, no podemos estar en esa rama si queremos borrarla, si queremos borrarla con todos los commits deberiamos usar git branch -D nombre

fast-forward merge: se puede aplicar cuando se quieren fusionar dos ramas y cuando los commits de la rama A esten contenidos en la rama B para hacerlo nos movemos a la rama que va a cambiar 
en este caso la A y una vez ahi usamos git merge + nombre de la rama, en este caso B.

recursive merge o padre multiple: nos movemos a la rama que queremos cambiar, la rama A y escribiriamos git merge B 
Solo se puede hacer si los cambios en las dos ramas son compatibles. Para forzar esta estrategia deberiamos usar 
git merge –-no-ff B. en caso de conflicto tendriamos que resolverlo nosotros.

para reescribir un commit usamos rebase, solo debemos hacerlo sobre commits que no hayamos compartido para cancelarlo usamos git rebase --abort

tambien podemos usar squash que haria lo mismo que el rebase, solo que el rebase por cada commit haria un commit, y el squash haria solo 1 commit

GITHUB

separar palabras en repositorios con -, todo en minuscula

git remote muestra los repositorio remotos que tenemos
git remote add origin (es el nombre del remote por convenio) url
git remote show te muestra los detalles de un remote
para eliminar un remoto git remote remove (nombre de remoto)
con git push empujamos los commits que estan en local y no estan en remoto
la opcion -u del git push es para hacerle ver al remoto que las ramas master de local y remota son la misma
si lo pusieramos la rama en local seria una rama de seguimiento, es decir, la rama local estaria actualizada de todo cambio en la remota
de ahi en adelante solo usariamos git push

con git clone creamos un repositorio local con un remoto si ponemos despues de la url un nombre le ponemos ese nombre en la carpeta
origin/master representa localmente al repositorio remoto es decir, la ultima vez que se actualizo el remoto el master apuntaba a ese commit (no esta sincronizado en tiempo real y no se puede mover)
origin/HEAD solo aparece cuando haces un clone y te dice cual es la rama principal del repositorio remoto
con git remote show origin se conecta a internet y comprueba el remoto y el local

con git fetch te traes commits del remoto y despues tenemos que hacer un git merge o un git rebase

git pull es un git fetch + un git merge si queremos hacerlo con rebase tendriamos que poner git pull --rebase

para eliminar la rama remota primero la eliminamos en local y despues git push --delete origin nombreDeRama o git push origin :nombreDeRama (este ultimo tambien borra etiquetas remotas)
para eliminar punteros locales que han sido eliminados usamos git remote prune origin o git push origin :nombreDeRama
con git push no pusheamos etiquetas, para pushearlas tenemos que poner git push origin etiqueta ó  git push --tags (pushea todas las etiquetas)

una pull request es una peticion que le hacemos al dueño del repositorio para que integre cambios en una rama

las issues sirven para que queden constancia en el repositorio que existe una anomalia, tambien puede ser una mejora. Lo suyo seria llamar a la rama  (numero de incidencia)-(descripcion corta)
  
si queremos generar una version para el usuario final deberemos crear una release

el fork sirve para hacer una copia clonada del repositorio y trabajar en ese repositorio. Cuando pusheas una rama forkeada hace automaticamente un pull request. 

para actualizar repositorios remotos: Git stash, git pull y git stash pop

Tema 3

cookies:
tienen un limite de 50 por sitio, 4kb de tamaño
estan compuesta por nombre,contenido,dominio,ruta, enviar para tipos de conexion, accesible para secuencias de comandos y caducidad.

Tema 4

en php vamos por snake case, por ejemplo is_null()

para ejecutar codigo php : php + archivo en la terminal
si ponemos php -a pasamos al modo interactivo y le pasamos las ordenes directamente
con el script hemos instalado otro interprete llamado psysh
con la asignacion por referencia $x=$y si cambiamos el valor de y cambiamos el de x, si eliminamos una no eliminamos la otra
$argc te dice los argumentos que le pasas, siendo 1 cuando ejecutas el script y n+1 por n elementos que le pasas
bool=booleanos, int =enteros, float=decimal
potencia = 2 ** 3
concatenacion = "hola"." pepe"
strlen te devuelve los bytes de una cadena
strrev invierte cadena
strpos te devuelve la primera posicion de una subcadena dentro de una cadena
strrpos te devuelve la ultima posicion de una subcadena dentro de una cadena
substr devuelve una subcadena de una cadena
trim elimina espacios de principio y final de cadena
para trabajar con cadenas especiales deberemos usar las funciones mb_(funcion)
para acceder a un caracteren una determinada posicion de una cadena usamos mb_substr(cadena,posicion,1)

para comprobar la nulidad de una variable usariamos is_null($x)

una variable es nula si se le ha asignado null, si aun no tiene valor o si se le ha hecho unset

notice<warning<errores ; cada cual es mas ""peligroso"" que el anterior

comprobaciones de tipos 

gettype() te de vuelve el tipo

is_(tipo) te devuelve si una variable es de un tipo en concreto

comprobaciones de valores

is_numeric() te devuelve si una variable es un numero o un string numerico

ctype_*() devuelve si en una variable todos los caracteres son *  esto es lo mas util de todo 

conversiones de tipos= casting de java de normal no suele ser necesaria
tambien podemos usar *val()

https://www.php.net/manual/es/language.types.type-juggling.php


comparaciones de datos
https://www.php.net/manual/es/language.operators.comparison.php
https://www.php.net/manual/es/types.comparisons.php

a??b = devuelve a si no es nulo, si es nulo devuelve b

condicion?: valor falso (esto es una contraccion del ternario)

podemos definir constantes con define("nombre en mayusculas",valor) o const "nombre en mayusculas"=valor;



Tema 5

Estructuras de control
https://www.php.net/manual/es/language.control-structures.php

if (condicion):
----
elseif(condicion):
----
else:
----
endif;

switch():
---
case()
---
endbreak;

while(condicion):
---
endwhile;

for():
---
endfor;


la diferencia entre un require y un include es que el include no para el programa pero el require si 

require_once y include_once abren los archivos una sola vez

en el require|include el nombre tiene que estar con el nombre completo

al pasar al siguiente archivo el interprete se pone en modo html

un archivo que incluyes puede devolver un valor (con return) se guarda con $x= require"fichero.php" devuelve false en caso de fallo

Cuando se incluye un archivo, el código que contiene hereda el ámbito de las variables de la línea en la cual ocurre la inclusión. Cualquier variable disponible en esa línea del archivo que hace la llamada,
estará disponible en el archivo llamado, desde ese punto en adelante. Sin embargo, todas las funciones y clases definidas en el archivo incluido tienen el ámbito globa

despues de buscar el fichero en el directorio actual lo busca en el include_path .:/usr/share/php eso pasa cuando no indicas una ruta

para asegurarte que no va a mirar en el include_path debemos poner el ./ delante del nombre del fichero

la constante __DIR__ deberiamos de usarla con los require por ejemplo require __DIR__ . "sub/dos.php"

isset(): determina si una variable esta definida y no es null

empty(): determina si una variable esta vacia. Una variable esta vacia si no existe o si su valor esta vacio empty($c)&&!is_numeric($c) te vale para las cadenas vacias y falsas, si no ponemos el !isnumeric entrarian las cadenas con 0

var_dump(): te dice que contiene esa variable y el tipo de la variable. si esta en un script te dice ademas la ruta del script y la linea en la que esta a veces es mejor usar el print_r cuando hay datos muy anidados

Arrays:


son dinamicos y se pueden crear de tres formas 

array() viejo

se llama la funcion array y se le da los valores: array("juan",5,2,6.5)

[] moderno

se llama a [] y se le da los valores: ["juan".5,2,6.5]

$a[] = x => añade el elemento x al final del array. Exista $a o no

count(array)= te dice el numero de elementos que tiene

con unset() tambien eliminamos el elemento. si eliminamos una posicion que no es la ultima borramos tanto el valor como el indice
es decir unset($a[2]) echo $a => estarian todos los indices menos el 2 

Todos los elementos se añaden siempre por el final

por este motivo deberiamos recorrer el array usariamos foreach:

foreach($a as $k=>$v){}

Funciones de Arrays:

https://www.php.net/manual/es/book.array.php

sort($array):Te ordena el array que le envias, no te devuelve otro array, te devuelve un booleano. Te borra las claves, empiezan por 0 y termina por count($array)

rsort($array):Igual que el anterior solo que ordena en orden inverso

asort($array): Ordena un array y mantiene la asociacion de indices.

arsort($array): Igual que el anterior solo que ordena en orden inverso

ksort($array): Ordena un array por claves

krsort($array): Igual que el anterior solo que ordena en orden inverso

natsort($array): Ordena de forma natural, no lexicofrafico

natcasesort($array) Igual que el anterior solo que es insensible a mayusculas y minuscula

usort() uksort() uasort(): Ordena por un orden definido por el usuario ya lo veremos cuando seamos mas inteligentes si eso

para mostrar arrays deberiamos usar print_r()

array_merge($array, $array2...): Combina dos o mas arrays, si son claven String y son iguales se sobreescriben, antiguo se sobreescribe

$array + $array2: Combina dos arrays, si las claves son iguales, numericas o no, prevalece el primero

para saber si un elemento de un array existe podemos usar isset(), pero lo mejor es usar array_key_exists(clave,array) asi sabremos que existe esa clave aunque su valor sea nulo

Pero lo que deberiamos usar es isset($a[1])||array_key_exists(1,$a)

el casting de array (array) x mola con objetos

array_keys(): Devuelves las claves de un array

array_values(): Devuelve los valores de un array

array_combine(): Recibe dos arrays, devuelve un array, siendo el primer array las claves y el segundo los valores

